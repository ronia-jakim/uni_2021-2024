\section{JĘZYK LOGIKI}

\subsection{FUNKCJE}
\begin{center}\large
    {\color{def}FUNKCJA} - zbiór par uporządkowanych o właśności jednoznaczości,\\
    czyli nie ma dwóch par o tym samym poprzedniku i dwóch różnych następnikach.
\end{center}\bigskip
Teraz dziedzinę i przeciwdziedzinę określamy poza definicją funkcji - nie są na tym \\samym poziomie co sama funkcja:
\begin{align*}
    \dom{f}&=\{x\;:\;(\exists\;y)\;\langle x,y\rangle\in f\}\\
    \rng{f}&=\{y\;:\;(\exists\;x)\;\langle x,y\rangle\in f\}.
\end{align*}
Warto pamiętać, że {\color{acc}definicja funkcji} jako \emph{podzbioru $f\in X\times Y$ takiego, że dla każdego $x\in X$ istnieje dokładnie jeden $y\in Y$ takie, że $\langle x,y\rangle \in f$} jest tak samo poprawną defini-\\cją, tylko {\color{emp}kładzie nacisk na inny aspekt} funkcji.

\subsection{OPERACJE UOGÓLNIONE}
Dla {\color{def}rodziny indeksowanej} $\{A_i\;:\;i\in I\}$ definiujemy:\smallskip\\
    \indent - jej sumę: $\bigcup\limits_{i\in I}A_i = \{x\;:\;(\exists\;i\in I)\;x\in A_i\}$\smallskip\\
    \indent - jej przekrój: $\bigcap\limits_{i\in I}A_i=\{x\;:\;(\forall\;i\in I)\;x\in A_i\}$\medskip\\
Dla {\color{def}nieindeksowanej rodziny zbiorów} $\mathcal{A}$ definiujemy:\smallskip\\
    \indent - suma: $\bigcup\mathcal{A} = \{x\;:\;(\exists\;A\in\mathcal{A})\;x\in A\}$\smallskip\\
    \indent - przekrój: $\bigcap\mathcal{A}=\{x\;:\;(\forall\;A\in\mathcal{A})\;x\in A\}$\medskip\\
Formalnie, indeksowana rdzina zbiorów jest funkcją ze zbioru indeksów w rodzinę zbio-\\rów, więc powinna być zapisywana w nawiasach trójkątnych (para uporządkowana). Sto-\\sowany przez nas zapis w nawiasach klamrowych oznacza zbiór wartości takiej funkcji \\i nie ma znaczenia czy dany podzbiór pojawi się w nim wielokrotnie. Nie przeszkadza \\to więc w definiowaniu sumy czy przekroju.\bigskip\\

\podz{gr}\bigskip\\

{\large{\color{def} UOGÓLNIONY ILOCZYN KARTEZJAŃSKI} (uogólniony produkt) zbiorów:}\medskip\\
Dla dwóch i trzech zbiorów mamy odpowiednio:
$$A_1\times A_2=\{\parl x,y\parr\;:\;x\in A_1\land y\in A_2\}$$
$$A_1\times A_2\times A_3=\{\parl x,y,z\parr\;:\;x\in A_1\land y\in A_2\land z\in A_3\}.$$
Pierwszym pomysłem na definiowanie iloczynu kartezjańskiego trzech i wiecej zbiorów \\będzie definicja rekurencyjna:
$$A_1\times A_2\times A_3:=(A_1\times A_2)\times A_3.$$

Pojawia się problem formalny - {\color{emp}iloczyn kartezjański nie jest łączny}:
$$(A_1\times A_2)\times A_3\neq A_1\times (A_2\times A_3)$$
$$\parl\parl a_1, a_2\parr a_3\parr\neq\parl a_1,\parl a_2,a_3\parr\parr.$$
\emph{Mimo, że iloczyn kartezjański nie jest łączny, matematycy nie mają problemu uznawać, \\że jest łączny, gdyż {\color{acc}istnieje naturalna, kanoniczna bijekcja}, która lewej stronie \\przypisuje prawą stronę.}\medskip\\

Niech $\parl A_i\;:\;i\in I\parr$ będzie indeksowaną rodziną zbiorów, czyli
$$A:I\to\bigcup\limits_{i\in I}A_i$$
$$A(i)=A_i$$
Wyobraźmy sobie iloczyn kartezjański dwóch zbiorów nie jako punkt na płaszczyźnie, \\ale jako dwuelementowy ciąg:
\pmazidlo
\draw[white, thick] (0, 0) -- (0, 2);
\draw[white, thick] (2, 0) -- (2, 2);
\draw[acc, ultra thick] (0, 0.5) -- (2, 1.5);
\filldraw [color=acc, fill=back, thick] (0, 0.5) circle (0.1);
\filldraw [color=acc, fill=back, thick] (2, 1.5) circle (0.1);
\node at (-0.3, 0.5) {$a_1$};
\node at (2.3, 1.5) {$a_2$};
\node at (0, -0.3) {$A_1$};
\node at (2, -0.3) {$A_2$};
\kmazidlo
To przedstawienie łatwo jest przełożyć na nieskończenie długi iloczyn kartezjański, \\wystarczy dorysować kolejne osie z elementami kolejnego podzbioru rodziny:
\pmazidlo
\draw[white, thick] (0, 0) -- (0, 2);
\draw[white, thick] (2, 0) -- (2, 2);
\node at (3, 1) {...};
\draw[acc, ultra thick] (0, 0.5) -- (2, 1.5);
\filldraw [color=acc, fill=back, thick] (0, 0.5) circle (0.1);
\filldraw [color=acc, fill=back, thick] (2, 1.5) circle (0.1);
\node at (-0.3, 0.5) {$a_1$};
\node at (2.3, 1.5) {$a_2$};
\node at (0, -0.3) {$A_1$};
\node at (2, -0.3) {$A_2$};
\draw[acc, ultra thick] (2, 1.5)--(2.4, 1.2);
\draw[acc, ultra thick] (3.6, 1) -- (4, 0.6);
\draw[white, thick] (4, 0)--(4, 2);
\filldraw[color=acc, fill=back, thick] (4, 0.6) circle (0.1);
\node at (4.3, 0.6) {$a_n$};
\node at (4, -0.3) {$A_n$};
\kmazidlo
W ten sposób powstaje funkcja, która kolejnym indeksom przypisuje element z tego inde-\\ksu:
$$f:I\to \bigcup\limits_{i\in I} A_i$$
$$f(i)\in A_i.$$
Według tego, {\color{def}uogólniony iloczyn kartezjański to zbiór funkcji} ze zbioru indeksowego \\w rodzinę indeksowaną:
$$\prod\limits_{i\in I}A_i=\{f\in (\bigcup\limits_{i\in I}A_i)^I\;:\;(\forall\;i\in I)\;f(i)\in A_i\}$$
Jednak dla $I=\{1, 2\}$ nie zachodzi równość:
$$\prod\limits_{i\in I} A_i\neq A_1\times A_2$$
Po lewej mamy zbiór funkcji, a po prawej iloczyn kartezjański. Możemy pokazać natu-\\ralną bijekcję między lewą a prawą stroną, ale byty są róże. Wystarczy pamiętać, że \\mamy co innego i możemy się tym nie przejmować <3

\subsection{JĘZYK PIERWSZEGO RZĘDU}
{\color{emp}JĘZYK RZĘDU ZERO}, czyli rachunek zdań: $p, q, r, ..., \lor, \land, \neg, \implies, \iff$\bigskip\\
{\color{emp}JĘZYK PIERWSZEGO RZĘDU} jest nadzbiorem języka rzędu zero\medskip\\
{\color{acc}część logiczna:}\smallskip\\
    \indent 1. symbole zmiennych: $V=\{x_0, x_1, ...\}$\\
    \indent 2. symbole spójników logicznych: $\{\neg, \lor, \land, \implies, \iff\}$\\
    \indent 3. symbole kwantyfikatorów: $\{\forall, \exists\}$\\
    \indent 4. symbol równości: =\medskip\\
{\color{acc}część pozalogiczna:}\smallskip\\
    \indent 1. symbole funkcyjne: $F=\{f_i\;:\;i\in I\}$\\
    \indent 2. symbole relacyjne (predykaty): $R=\{r_j\;:\;j\in J\}$\\
    \indent 3. symbole stałe: $C=\{c_k\;:\; k\in K\}$\medskip\\
{\color{def}ARNOŚĆ} - odpowiada liczbie argumentów funkcji lub relacji. Każdy symbol ma swoją \\arność.\smallskip\\
{\color{def}SYGNATURA} - zawiera informację o tym, ile jest symboli funkcyjnych, relacyjnych lub \\stałych i jakiej są arności w danym języku. Sygnatura charakteryzuje język.

\subsection{SYNTAKTYKA vs SEMANTYKA}
\emph{Znała suma cała rzeka,\\ 
Więc raz przbył lin z daleka\\
I powiada: "Drogi panie,\\
Ja dla pana mam zadanie,\\
Jeśli pan tak liczyć umie,\\
Niech pan powie, panie sumie,\\
Czy pan zdoła w swym pojęciu,\\
Odjąć zero od dziesięciu?"\\
(...)\\
"To dopiero mam z tym biedę - \\
Może dziesięc? Może jeden?" }\medskip\\
Jak odjąc 0 od 10:\\
    \indent semantycznie: 10 - 0 = 10\\
    \indent syntaktycznie: od ciągu 1 i 0 odjęcie 0 to zostawienie tylko 1\bigskip\\

{\color{def}SEMANTYKA} - patrzy na znaczenie zapisów, nie sam napis.\\
{\color{def}SYNTAKTYKA} - interesuje ją tylko zapis, język, a znaczenia nie ma.

\subsection{KONSTRUOWANIE JĘZYKA}
\begin{center}\large
    {\color{def}TERMY} - bazowy zbiór termów to \\zbiór zmiennych i zbiór stałych:\smallskip\\
    $T_0=V\cup C$\smallskip\\
    {\normalsize Do ich budowy wykorzystujemy symbole funkcyjne ($F$)}
\end{center}
Załóżmy, że mamy skonstruowane termy aż do rzędu $n$ i chcemy skonstruować termy rzędu \\$n+1$. Jeśli mamy symbol funkcyjny arności $k$, to {\color{emp}termem jest zastosowanie tego symbolu do wczesniej skonstruowanych termów}, których mamy $k$:
$$f\in F\quad f\texttt{ -arności k}$$
$$F(t_1, ..., t_k)\quad t_1, ..., t_k\in \bigcup\limits_{i=0}^n T_i$$
Czylil jeśli mamy zbiór termów, to \emph{\color{emp}biorąc wszystkie dostępne symbole funkcyjne i sto-\\sując je na wszystkie możliwe sposoby do dotychczas skonstruowanych termów} tworzone \\są nowe termy.\medskip
\begin{center}Termy to potencjalne wartości funkcji\end{center}\bigskip
\begin{center}\large
    {\color{def}FORMUŁY} - budowane są rekurencyjnie, zaczynając \\od formuł atomowych:\smallskip\\
    $t=s,\quad t,s\in TM$\smallskip\\
    stosując wszystkie relacje równoważności termów\smallskip\\
    $r\in R\quad r(t_1, ..., t_k)$\smallskip\\
    {\normalsize zastosowanie symbolu relacyjnego na odpowiedniej ilości termów tworzy formułę}
\end{center}\medskip
Bazowym poziomem frmuł jest formuła atomowa:
$$F_{m_0}=\{\varphi\;:\;\varphi\texttt{ - formuła atomowa}\}$$
Jeśli mamy $F_{m_k}$ dla pewnego $k<n$, czyli wszystkie formuły poniżej $n$ zostały skon-\\struowane, to
$$F_{m_n}\;:\;\neg\;(\varphi),\;\varphi\lor\phi,\;\varphi\land\phi,...\quad \texttt{dla }\varphi,\phi\in\bigcup\limits_{k<n}F_{m_k},$$
czyli {\color{emp}używamy wszystkich spójników logicznych} dla poprzednich formuł
$$F_{m_n}\;:\;(\forall\;\varphi)\;(\exists\;x_i)\quad \texttt{dla }\varphi\in\bigcup\limits_{k<n}F_{m_k},\;x_i\in V$$
{\color{emp}kwantyfikujemy też po wszystkich możliwych zmiennych wszystkiemożliwe formuły}
$$FM = \bigcup\limits_{n=0}^\infty F_{m_n}$$
\subsection{JĘZYK TEORII MNOGOŚCI}
\begin{center}\large
    {\color{def}$L=\{\in\}$}\smallskip\\
    składa się z jednego binarnego predykatu, \\który nie jest jeszcze należeniem
\end{center}\bigskip
W racuhnku zdań przejście z syntaktyki do semantyki to nadanie symbolom wartości \\prawda lub fałsz.\bigskip
\begin{center}\large
    {\color{def}SYSTEM ALGEBRAICZNY:}\smallskip\\
    {\color{emp}$\rodz{A}=\parl A,\{F_i\;:\;i\in I\},\{R_j\;:\;j\in J\},\{C_k\;:\;k\in K\}\parr$}\smallskip\\
    {\normalsize odpowiednio: zbiór (uniwersum), funkcje na $A$, relacje na $A$, stałe w $A$}
\end{center}\medskip
przykłady: $\parl \Po\N,\subseteq\parr, \;\parl \R, +, \cdot, 0, 1\leq\parr$\bigskip\\
Język $L$ możemy interpretować w systemie $\rodz A$ o ile mają one tę samą sygnaturę.\bigskip
\begin{center}\large
    {\color{def}INTERPRETACJA} to funkcja ze zbioru wartości w uniwersum:\smallskip\\
    $i\;:\;V\to \rodz A,$\smallskip\\
    którą można rozszerzyć do funkcji ze zbioru termów w uniwersum:\smallskip\\
    $\overline i \;:\;TM\to \rodz A$\\
    $i\subseteq \overline i$
\end{center}\bigskip
Ponieważ sygnatury są takie same, to każdemu symbolowi funkcyjnemu możemy przypisać \\funkcję o dokładnie tej samej arności. \emph{Czyli jeśli dany symbol funkcyjny jest nakła-\\dany na termy, to odpowiadająca mu funkcja jest nakładana na wartości tych termów.}\bigskip
\begin{center}\large
    {\color{emp}W systemie $\rodz A$ formuła $\varphi$ jest spełniona przy interpretacji $i$:}\smallskip\\
    $\rodz A \models \varphi[i]$
\end{center}\bigskip
Zaczynamy od formuł atomowych, czyli:\medskip\\
\begin{tabular} { m{3cm} m{15cm} }
    {\color{acc}$\rodz A\models (t=s)[i]$} & wtedy i tylko wtedy, gdy mają tę samą interpretację (czyli $\overline i(t)=\overline i(s)$)\\
    {\color{acc}$\rodz A\models r_j(t_1,...,t_k)[i]$} & wtedy i tylko wtedy, gdy odpowiedająca temu predykatowi relacja zachodzi na wartościach termów (czyli $R_j(\overline i (t_1), ..., \overline i (t_k))$)\\
    {\color{acc}$\rodz A \models (\neg\;\varphi)[i]$} & \makecell[tl]{wtedy i tylko wtedy, gdy nieprawda, że $\rodz A \models \varphi[i]$, i tak ze wszy-\\stkimi spójnikami logicznymi}\\
    {\color{acc}$\rodz A\models (\forall\;x_m)\;\varphi[i]$} & \makecell[tl]{wtedy i tylko wtedy, gdy dla każdego $a\in \rodz A$ mamy $\rodz A\models \varphi[i({x_m\over a})]$ (spraw-\\dzamy dla konkretnego $a$ czy spełnia$\varphi$, a potem dla $x_m$ przypisujemy to \\$a$, natomiast inne wartości dostają podstawienie $({x_m\over a})$?)}
\end{tabular}
